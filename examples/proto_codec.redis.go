// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto_codec.proto

package test

import context "context"
import github_com_gomodule_redigo_redis "github.com/gomodule/redigo/redis"
import github_com_mitchellh_mapstructure "github.com/mitchellh/mapstructure"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/galaxyobe/protoc-gen-redis/proto"
import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// new StringProtoCodec redis controller with redis pool
func (m *StringProtoCodec) RedisController(pool *github_com_gomodule_redigo_redis.Pool) *StringProtoCodecRedisController {
	return &StringProtoCodecRedisController{
		pool: pool,
		m:    m,
	}
}

// StringProtoCodec redis controller
type StringProtoCodecRedisController struct {
	pool *github_com_gomodule_redigo_redis.Pool
	m    *StringProtoCodec
}

// new StringProtoCodec redis controller with redis pool
func NewStringProtoCodecRedisController(pool *github_com_gomodule_redigo_redis.Pool) *StringProtoCodecRedisController {
	return &StringProtoCodecRedisController{pool: pool}
}

// get StringProtoCodec
func (r *StringProtoCodecRedisController) StringProtoCodec() *StringProtoCodec {
	return r.m
}

// store StringProtoCodec to redis string with context and key
func (r *StringProtoCodecRedisController) Store(ctx context.Context, key string, ttl uint64) error {
	// redis conn
	conn := r.pool.Get()
	defer conn.Close()

	// marshal StringProtoCodec to []byte
	data, err := proto.Marshal(r.m)
	if err != nil {
		return err
	}

	// use redis string store StringProtoCodec data with expire second
	_, err = conn.Do("SETEX", key, ttl, data)

	return err
}

// load StringProtoCodec from redis string with context and key
func (r *StringProtoCodecRedisController) Load(ctx context.Context, key string) error {
	// redis conn
	conn := r.pool.Get()
	defer conn.Close()

	// load data from redis string
	data, err := github_com_gomodule_redigo_redis.Bytes(conn.Do("GET", key))
	if err != nil {
		return err
	}

	// unmarshal data to StringStorageType
	return proto.Unmarshal(data, r.m)
}

// new HashProtoCodec redis controller with redis pool
func (m *HashProtoCodec) RedisController(pool *github_com_gomodule_redigo_redis.Pool) *HashProtoCodecRedisController {
	return &HashProtoCodecRedisController{
		pool: pool,
		m:    m,
	}
}

// HashProtoCodec redis controller
type HashProtoCodecRedisController struct {
	pool *github_com_gomodule_redigo_redis.Pool
	m    *HashProtoCodec
}

// new HashProtoCodec redis controller with redis pool
func NewHashProtoCodecRedisController(pool *github_com_gomodule_redigo_redis.Pool) *HashProtoCodecRedisController {
	return &HashProtoCodecRedisController{pool: pool}
}

// get HashProtoCodec
func (r *HashProtoCodecRedisController) HashProtoCodec() *HashProtoCodec {
	return r.m
}

// load HashProtoCodec from redis hash with context and key
func (r *HashProtoCodecRedisController) Load(ctx context.Context, key string) error {
	// redis conn
	conn := r.pool.Get()
	defer conn.Close()

	// load data from redis hash
	data, err := github_com_gomodule_redigo_redis.ByteSlices(conn.Do("HGETALL", key))
	if err != nil {
		return err
	}

	// parse redis hash field name and value
	structure := make(map[string]interface{})
	for i := 0; i < len(data); i += 2 {
		switch string(data[i]) {
		case "HashProtoCodec":
			// unmarshal HashProtoCodec
			r.m.HashProtoCodec = new(HashProtoCodec)
			if err := proto.Unmarshal(data[i+1], r.m.HashProtoCodec); err != nil {
				return err
			}
		default:
			structure[string(data[i])] = string(data[i+1])
		}
	}

	// use mapstructure weak decode structure to HashProtoCodec
	return github_com_mitchellh_mapstructure.WeakDecode(structure, r.m)
}

// store HashProtoCodec to redis hash with context and key
func (r *HashProtoCodecRedisController) Store(ctx context.Context, key string, ttl uint64) error {
	// redis conn
	conn := r.pool.Get()
	defer conn.Close()

	// make args
	args := make([]interface{}, 0)

	// add redis key
	args = append(args, key)

	// add redis field and value
	args = append(args, "SomeString", r.m.SomeString)
	args = append(args, "SomeBool", r.m.SomeBool)
	args = append(args, "SomeInt32", r.m.SomeInt32)
	args = append(args, "SomeUint32", r.m.SomeUint32)
	args = append(args, "SomeInt64", r.m.SomeInt64)
	args = append(args, "SomeUint64", r.m.SomeUint64)
	args = append(args, "SomeFloat", r.m.SomeFloat)
	// marshal HashProtoCodec
	if r.m.HashProtoCodec != nil {
		HashProtoCodec, HashProtoCodecError := proto.Marshal(r.m.HashProtoCodec)
		if HashProtoCodecError != nil {
			return HashProtoCodecError
		}
		args = append(args, "HashProtoCodec", HashProtoCodec)
	}

	// use redis hash store HashProtoCodec data with expire second
	err := conn.Send("MULTI")
	if err != nil {
		return err
	}
	err = conn.Send("HMSET", args...)
	if err != nil {
		return err
	}
	err = conn.Send("EXPIRE", key, ttl)
	if err != nil {
		return err
	}
	_, err = conn.Do("EXEC")

	return err
}
